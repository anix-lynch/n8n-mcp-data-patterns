// Statistical Analysis Logic for Data Quality Audit\n// This code runs in the n8n Code Node\n\n// Read the full dataset\nconst fs = require('fs');\nconst filePath = $input.first().json.file_path;\n\n// Parse CSV data\nconst fileContent = fs.readFileSync(filePath, 'utf8');\nconst lines = fileContent.split('\\n').filter(line => line.trim() !== '');\nconst headers = lines[0].split(',').map(h => h.trim());\nconst dataRows = lines.slice(1);\n\n// Initialize statistics object\nconst stats = {\n  total_rows: dataRows.length,\n  total_columns: headers.length,\n  missing_data_analysis: {},\n  basic_statistics: {}\n};\n\n// Analyze each column\nheaders.forEach((header, index) => {\n  const columnData = dataRows.map(row => {\n    const cells = row.split(',');\n    return cells[index] ? cells[index].trim() : '';\n  });\n  \n  // Count missing values\n  const missingCount = columnData.filter(cell => \n    cell === '' || \n    cell.toLowerCase() === 'null' || \n    cell.toLowerCase() === 'n/a' || \n    cell === 'undefined'\n  ).length;\n  \n  stats.missing_data_analysis[header] = {\n    missing_count: missingCount,\n    missing_percentage: ((missingCount / dataRows.length) * 100).toFixed(2)\n  };\n  \n  // Basic stats for numeric columns\n  const numericValues = columnData\n    .filter(cell => cell !== '' && !isNaN(parseFloat(cell)))\n    .map(cell => parseFloat(cell));\n  \n  if (numericValues.length > 0) {\n    const sorted = numericValues.sort((a, b) => a - b);\n    const mean = numericValues.reduce((sum, val) => sum + val, 0) / numericValues.length;\n    const variance = numericValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / numericValues.length;\n    const stdDev = Math.sqrt(variance);\n    \n    // Outlier detection using 3-sigma rule\n    const outliers = numericValues.filter(val => Math.abs(val - mean) > 3 * stdDev);\n    \n    stats.basic_statistics[header] = {\n      count: numericValues.length,\n      mean: mean.toFixed(2),\n      std_dev: stdDev.toFixed(2),\n      min: sorted[0],\n      max: sorted[sorted.length - 1],\n      median: sorted[Math.floor(sorted.length / 2)],\n      potential_outliers: outliers.length,\n      outlier_values: outliers.slice(0, 5) // Show first 5 outliers\n    };\n  }\n});\n\n// Calculate overall data quality score\nfunction calculateQualityScore() {\n  let score = 100;\n  \n  // Penalize missing data\n  const avgMissingPct = Object.values(stats.missing_data_analysis)\n    .reduce((sum, col) => sum + parseFloat(col.missing_percentage), 0) / headers.length;\n  score -= avgMissingPct * 2; // 2 points per % missing\n  \n  // Penalize high outlier ratios\n  const numericColumns = Object.values(stats.basic_statistics);\n  if (numericColumns.length > 0) {\n    const avgOutlierPct = numericColumns\n      .reduce((sum, col) => sum + (col.potential_outliers / col.count) * 100, 0) / numericColumns.length;\n    score -= avgOutlierPct * 1; // 1 point per % outliers\n  }\n  \n  // Penalize columns with >50% missing\n  const criticalMissingColumns = Object.values(stats.missing_data_analysis)\n    .filter(col => parseFloat(col.missing_percentage) > 50).length;\n  score -= criticalMissingColumns * 10; // 10 points per critical column\n  \n  return Math.max(0, Math.min(100, score));\n}\n\nstats.overall_quality_score = calculateQualityScore().toFixed(1);\nstats.timestamp = new Date().toISOString();\n\n// Generate quality insights\nstats.quality_insights = {\n  critical_issues: [],\n  warnings: [],\n  recommendations: []\n};\n\n// Flag critical issues\nObject.entries(stats.missing_data_analysis).forEach(([col, data]) => {\n  if (parseFloat(data.missing_percentage) > 30) {\n    stats.quality_insights.critical_issues.push(`${col}: ${data.missing_percentage}% missing data`);\n  } else if (parseFloat(data.missing_percentage) > 10) {\n    stats.quality_insights.warnings.push(`${col}: ${data.missing_percentage}% missing data`);\n  }\n});\n\n// Flag outlier issues\nObject.entries(stats.basic_statistics).forEach(([col, data]) => {\n  if (data.potential_outliers > 0) {\n    const outlierPct = ((data.potential_outliers / data.count) * 100).toFixed(1);\n    if (data.potential_outliers > data.count * 0.05) { // >5% outliers\n      stats.quality_insights.warnings.push(`${col}: ${data.potential_outliers} outliers (${outlierPct}%)`);\n    }\n  }\n});\n\n// Generate recommendations\nif (stats.quality_insights.critical_issues.length > 0) {\n  stats.quality_insights.recommendations.push('Address critical missing data before analysis');\n}\nif (stats.quality_insights.warnings.length > 3) {\n  stats.quality_insights.recommendations.push('Implement data validation at collection point');\n}\nif (parseFloat(stats.overall_quality_score) < 70) {\n  stats.quality_insights.recommendations.push('Consider data cleaning pipeline before production use');\n}\n\nreturn { json: stats };\n\n// Utility functions for advanced analysis\nfunction detectDataTypes(columnData) {\n  const sample = columnData.filter(cell => cell !== '').slice(0, 100);\n  \n  const patterns = {\n    email: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n    phone: /^[\\+]?[1-9]?[0-9]{7,15}$/,\n    date: /^\\d{4}-\\d{2}-\\d{2}$|^\\d{2}\\/\\d{2}\\/\\d{4}$/,\n    currency: /^\\$?\\d+(\\.\\d{2})?$/,\n    percentage: /^\\d+(\\.\\d+)?%$/\n  };\n  \n  const typeScores = {};\n  Object.entries(patterns).forEach(([type, pattern]) => {\n    typeScores[type] = sample.filter(val => pattern.test(val)).length / sample.length;\n  });\n  \n  return typeScores;\n}\n\nfunction calculateEntropy(columnData) {\n  const values = columnData.filter(cell => cell !== '');\n  const counts = {};\n  values.forEach(val => counts[val] = (counts[val] || 0) + 1);\n  \n  const total = values.length;\n  let entropy = 0;\n  \n  Object.values(counts).forEach(count => {\n    const probability = count / total;\n    entropy -= probability * Math.log2(probability);\n  });\n  \n  return entropy;\n}"